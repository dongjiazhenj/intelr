## ELF Binary Rewriter
This is a baseline binary instrumentation tool for x86 ELF binaries on Linux. It works on both 64-bit and 32-bit ELF files and it works properly on Position-Independent Executable (PIE), non-PIE and shared libaries.

## Background
Binary instrumentation often requires inserting new code or data into an existing binary. However, ELF files compiled by modern compilers (gcc and llvm) do not have sufficient space to put such extra information. This is because that compilers would generate binaries in a compact form for smaller memory footprint.

This tool helps solving the space issue for binary instrumentation/rewriting. It works by extending an existing ELF file with extra loadable (PT_LOAD) segments, following the specification of program loaders. The binaries generated by this tool should work well with all functionality preserved.

## Getting Started
To get started, check out files in examples directory.

### Writing your code in ASM and inject your code.
To write your code in assembly, you need to put your code in a ".s" file and use assembler to generated an object file. For instance, you may write the following assembly code in a file called test.s:
```
.global _start
_start:
  xorq %rax,%rax
```
After finishing code development, you may assemble it into an object file:
```
gcc -c test.s
```
Now inject your code into an existing file and execute the new file
```
./example/inject_only_code_segment.py -f /bin/ls -i test.o -o myls
./myls
```
Note:
 - "/bin/ls" is the file you want to instrument;
 - only the ".text" section of test.o will be injected into /bin/ls
 
### Writing your code in C (limited support) and instrument original code.
Finish the steps in [tutorial](../patch/tutorial/README.md) to see how to write your instrumentation code in C.

Instrument the binary with your instrumentation code.
```
src/analysis/patch-binary.sh /bin/ls your_instrument_code ./newls
./newls
```
Note that instrumentation code written in C has the following limited support:
 - only local variable and constant variable definition is supported.
 - only system call wrapper and PLT functions are supported for hooking.
 - only support hooking direct jumps and direct calls.
